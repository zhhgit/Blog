---
layout: post
title: "LeetCode思路整理"
description: LeetCode思路整理
modified: 2018-09-30
category: Algorithm
tags: [Algorithm]
---

2016年参加工作以来，为了提高基础能力、保持编码手感，进行了三轮LeetCode Java刷题。

第一遍：2016.12-2017.4，106题，主要是easy和medium的题。第一遍感觉非常吃力，很多题目是看别人的解答去理解，并逐渐熟练语法特性。

第二遍：2017.10.-2018.3，187题，主要是easy和medium的题，少部分hard题目。这一遍头脑里从混乱无章法到逐渐有逻辑有思路。

第三遍：2018.4-2018.9，155题，初始题库前155题的各类型题，大部分easy和medium可以有思路并解答，部分hard题还得看解答。

# 一、题目思路整理

前155题及思路整理如下，三遍刷题代码见github。（近期逐渐整理）

#### 1.有序数组中找到两个数，和正好为某个值，返回这两个数字的序号。

思路：没有说数组是否有序，所以一定不可能是先sort之后再去找的。那就需要按照原排列顺序，需要记住曾经出现过的数字的位置。HashMap。

#### 2.两个数值从后往前的链表，数值做加法，返回新链表。

思路：用0补齐长度，然后分别计算每一个节点相加的和，注意进位。

#### 3.字符串中最长的不包含重复字符的子字符串，返回该字符串的长度。

思路：碰到曾经出现的字符，就从队列头部开始移除，直至移除相同的字符。

#### 4.两个有序数组，返回所有数字排序后的中位数。

思路：数组长度假设分别为m,n。假设i,j分别为两个数组中的切割点。分别切割为A[0]---A[i-1],A[i]---A[m-1]和B[0]---B[j-1],B[j]---B[n-1];
应该保证j = (m+n+1)/2 - i。此时和为偶数时，两边各一半，为奇数时，左边比右边长1。
目标就是寻找一个合适的i,使得A[i-1] <= B[j],B[j-1] <= A[i]，此时所有两侧正好分成两半，且左侧的都小于右侧的。
特殊情况要考虑，切割点在最左、最右侧时。

#### 5.返回字符串的子字符串中最长的回文字符串。

思路：从字符串的每个位置开始向两侧扩张。两种方式，一种是从同一个位置开始，另一种是从相邻位置开始。

#### 6.原字符转按照蛇形方式重新排序成n行，返回重排后各行拼接而成的字符串。

思路：对字符分组，并找规律，List&lt;List&lt;Character&gt;&gt;。

#### 7.反转整数。

思路：用long类型来转换，考虑溢出的情况。

#### 8.字符串转化为整数。

思路：考虑各种异常情况，开头空白，开头非数字，正负号等。

#### 9.判断一个数字是否为回文数。

思路：回文数都是正整数，long类型先翻转数字顺序，再比较。

#### 10.判断字符串与正则字符串是否匹配。字符.代表任意一位，字符 * 与前一位组合代表0位或者多位。

思路：二维数组，如果s，p新增的最后一位相等，或者p最后一位为.，则matrix[i + 1][j + 1]与左上角相等。
如果p最后一位为 * ，如果p中 * 的前一位与s中当前位相等，或者p中 * 的前一位为.，则a * 或者. * 匹配情况有三种：
matrix[i + 1][j + 1]为matrix[i + 1][j]（情况1：对应于一位），
或为matrix[i + 1][j - 1]（情况2：对应于0位）
或为matrix[i][j+1]（情况3：对应于多位）
否则a * 匹配0位。

#### 11.一个数组中的数代表容器的侧壁高度，选择两个侧壁，求最大容积。

思路：假设左右两边相比，左侧更小，那么右侧向中心移动时，不管右侧的新值比左侧值更小或者更大，都会使总储水量减小。所以此时不应该把右侧向中心移动，应该移动左侧。

#### 12.正整数转化为罗马字母表示的字符串

思路：对于每一位数字的替换应该抽象为one,half,full。要考虑0--9应该分别怎样替换。

#### 13.罗马字母转换为数字。

思路：先遍历一遍累加，再减去双倍的小数位于大数左侧的情况的和。

#### 14.一组字符串，找到共同的前缀。

思路：依次检查每个位置，所有的字符串是否都是相同的char

#### 15.一个数组，找到其中可重复的三个数字和为0，返回这样的三个数的所有解答，即List&lt;List&lt;Integer&gt;&gt;。

思路：对于每个数字，通过left，right来夹逼remain。特别要注意造成超时的几个点：
(1)选取第一个数字时候，如果有重复要跳过；
(2)在每一轮的left,right夹逼remain时候，如果remain小于0，可以直接跳过；
(3)lists.contains(addList)判断是否重复，会造成超时；
(4)nums[left] + nums[right] == remain找到后，先left++,right--，然后要跳过重复；
(5)不等于remain时候，单边的left++或者right--也可以跳过重复（不跳过不会超时）；

#### 16.一个数组，找到其中可重复的三个数字和，与target值最接近，返回最接近的三个数的和。

思路：与15题类似，通过left，right来夹逼remain。

#### 17.电话上2-9的数字分别代表几个字符，给出一个数字字符串，求所有可能对应的字符串。

思路：(1)backTracking，更优。(2)处理每一位时，将list中已经存在的String全部取出处理一遍。

#### 18.一个数组，找到其中可重复的四个数字和为target，返回这样的四个数的所有解答，即List&lt;List&lt;Integer&gt;&gt;。

思路：与15题类似，双层循环，然后最后两个数left，right左右夹逼。

#### 19.一个链表，移除从末尾数第n个节点。

思路：快慢指针，特别要注意移除的是head的情况。

#### 20.判断字符串是否为合法闭合的括号对。

思路：Deque&lt;Character&gt;当做栈使用，注意要保证stack中有元素，否则stack.peek()为null，null再与'(','[','{'在用==比较时，会抛异常。

#### 21.merge两个有序链表。

思路：递归，每次处理一个ListNode。

#### 22.返回所有由n对括号组成的合法闭合的括号对字符串。

思路：递归，左括号个数要比右括号个数多。

#### 23.k个有序链表，merge成一个。

思路：递归，每次处理一个ListNode。

#### 24.链表中的节点每两个一组交换位置。

思路：每两个作为一组，完成位置交换之后递归。

#### 25.链表中的节点每k个一组逆序。

思路：只考虑反转k个节点，后面的递归。

#### 26.有序数组中只留下不重复的数字，且都移动到数组的最前面。

思路：从前往后遍历，符合条件的依次填入相应的位置。

#### 27.有序数组中移除与指定数字相等的值，留下的都移动到数组的最前面。

思路：从前往后遍历，符合条件的依次填入相应的位置。

#### 28.返回子字符串第一次出现的起始位置。

思路：依次比较。

#### 29.不使用乘除法，实现两个整数相除。

思路：多次的位运算左移，要考虑边际的特殊情况。

#### 30.一个字符串和一个字符串数组（数组中所有字符串等长），返回字符串数组中全部字符串拼接得到的字符串，在第一个字符串中的起始位置。

思路：先建立一个HashMap记录words中词应该出现的次数，再遍历字符串，每次截取等长的，如果出现不应该出现的，或者出现的次数超过应该出现的次数，就break，否则验证到最后了就是符合的。

#### 31.求比数组中数字代表的值大的下一个数组排列，对原数组操作。

思路：从末尾开始找到非递增的位置，然后从其后面找到一个比它稍大的数字的位置，并交换。最后重排非递增位置的后续其他位置的数。

#### 32.由小括号组成的字符串，求最长的正确闭合的子字符串的长度。

思路：依次以每个位置为起始，符合闭合的条件是left == right,可以继续循环的条件是left >= right。

#### 33.无重复数字的有序数组以某位置为轴反转，在其中寻找给定的数字，找到返回位置，没找到返回-1。

思路：判断转轴位置，以判断左右两侧哪侧递增。二分查找。

#### 34.有序数组中查找指定数字，返回指定数字的最左、最右位置，没有就返回[-1,-1]。

思路：二分查找，找到后向两边扩展。

#### 35.有序数组中查找指定数字，找到就返回其位置，没找到就返回其应该插入的位置。

思路：按顺序找到与target相等或者大于它的位置。

#### 36.给定9 * 9的不完整的数独二维数组，是否符合数独规则（行、列、3 * 3小区域）。

思路：分别验证行，列，每个区域。

#### 37.给定9 * 9的不完整的数独二维数组，在原二维数组上求解数独。

思路：backTracking依次填充每个空的位置，考虑数独规则哪些数字符合填充条件。要注意退出条件，可能已经找到了结果，但是在后续的循环中又把结果清除了。找到结果要及时退出。

#### 38.用“几个几”的方式读出数字，返回第n个数字。

思路：递归，第n个数字取决于第n-1个数字的读法。

#### 39.给定不包含重复数字的数组及目标和，返回所有和为目标和的数组，每个数字可以使用多次。

思路：backTracking。

#### 40.给定可能包含重复数字的数组及目标和，返回所有和为目标和的数组，每个数字可以使用一次。

思路：backTracking，注意与39题目调用backTracking函数时传参数的差异。

#### 41.给定无序数组，返回第一个缺失的正整数

思路：排序后，跳过非正数，然后找到第一个不满足等于或与前一个数差1的数字，就是缺数的位置 。

#### 42.非负数组表示坐标轴上每个位置的柱高度，返回最多储水量。

思路：对于每一个位置的值，应该分别找到左右两侧最大的值，找到其中较小的，减去当前位置的值，就是这个位置能够储水的量。

#### 43.两个非负字符串数字的乘法。

思路：考虑每一位数字计算的过程。

#### 44.通配符匹配字符串，s表示字符串，p表示正则表达式，?匹配一个字符， * 匹配空字符或任意长字符，返回是否匹配。

思路：两个指针分别移动，遇到？或者字符相等就都移动，遇到 * 记录最后一个 * 的位置和该 * 对应的最后一个字符位置，
都不符合如果曾出现 * ，有可能是 * 对应的很长。p指针回到 * 的下一个，加长 * 对应的字符串长度，移动match。s到最后时，如果p后面是 * 就移动。

#### 45.数组中数字表示在该位置可以跳的最远的步数，返回到达数组末尾所需的最少跳跃次数。

思路：curFarthest：当前位置能达到的最远位置，curEnd：当前步数能达到的最远位置，jumps：步数。
如果当前位置达到了当前步数能到达的最远位置，必须再跳一步，并将当前步数最远距离更新为当前位置最远距离。

#### 46.给定不包含重复数字的数组，返回数组中数字的所有排列组合。

思路：backTracking。

#### 47.给定可能包含重复数字的数组，返回数组中数字的所有排列组合。

思路：backTracking。

#### 48.n * n的二维数组，整体向右旋转，返回旋转后的二维数组。

思路：一圈圈依次交换每条边。

#### 49.字符串数组，将字符串归组，每组中的字符串都是相同字符重排后组成。

思路：重排序后的字符串作为key，value是对应的List&lt;String&gt;。

#### 50.求x的n次方，x为浮点数，n为整数。

思路：递归。考虑n为0，1，Integer.MIN_VALUE,x为0.0等异常情况。n分奇偶数考虑。

#### 51.给定n，返回所有的二维数组，使得n个Q，不在同一行、同一列、同一斜线上。

思路：backTracking。

#### 52.给定n，返回所有解的个数，使得n个Q，不在同一行、同一列、同一斜线上。

思路：同51题。

#### 53.给定数组，返回连续子数组和的最大值。

思路：retMax为全局的最大值。sums是和nums等长的数组，sums[i]表示以i结尾数组中最大的值。对于新添加的num[i]，有两种选择，要么已自己为头新开一个数组，要么跟前面的数组结合组成新数组。

#### 54.m * n的二维数组，返回按照顺时针顺序打印的数组。

思路：考虑什么情况下会有中间留下一行或者一列。依次访问每一圈的数字。

#### 55.数组中数字表示在该位置可以跳的最远的步数，返回是否可以跳到数组的末尾。

思路：每次计算最远到达的位置。

#### 56.给定一组区间，返回区间merge之后的结果。

思路：先依据interval.start排序，然后每次确定是否可以和下一个merge，能merge就merge，不能就把前一个放入结果的List&lt;Interval&gt;。

#### 57.给定一组区间，和一个待插入的区间，返回插入并merge之后的结果。

思路：判断能否merge，不能merge就放入结果list，否则再判断与下一个。

#### 58.返回包含空格的字符串中最后一个单词的。

思路：从末尾开始，考虑特殊情况。

#### 59.给定正整数n，返回以顺时针顺序旋入的n * n的二维数组。

思路：看有多少圈，然后处理每一圈的数字。

#### 60.给定n，返回1--n组成的数字排列中第k个排列。

思路：首先获得阶乘数组，计算每一位的值，除以的是(n-1)!，然后取pos个没有使用过的数值。

#### 61.链表向右反转k个位置。

思路：考虑k可能比链表长度要大，找到翻转的点。

#### 62.m * n的二维矩阵，原来位于左上角，目标位置位于右下角，只能向下向右走，问有多少总走法。

思路：用二维数组存储每个i,j位置的可能的种数。

#### 63.m * n的二维矩阵，二维矩阵中1表示障碍，原来位于左上角，目标位置位于右下角，只能向下向右走，问有多少总走法。

思路：用二维数组存储每个i,j位置的可能的种数，有障碍的地方置为0。

#### 64.m * n的二维数组，求从左上角到右下角的最小路径和。

思路：考虑边沿，比较上面和左侧的最小值。

#### 65.判断一个字符串是否为一个合法的十进制小数。

思路：考虑空格,'.','e',正负号在不同位置的特殊情况。定义seenNum、seenE、seenD分别表示是否见到数字、e、点号。
出现'.'，如果曾出现过点，或者曾出现e，就是非法的。
出现'e'，如果e曾经出现过，或者没有出现过数字，就是非法的。
正负号，如果不在首位，也不在e后面，就是非法的。
其他特殊字符，就是非法的。最后返回seenNum。

#### 66.返回数组中数组成的数字加1。

思路：考虑进位。

#### 67.两个非空二进制字符串相加。

思路：补成相同长度，考虑进位分别相加。

#### 68.给定字符串数组和最大宽度maxWidth，校正为等间距排列的字符串，返回校正后的每一行的字符串。

思路：确定哪些字符串可以放在一行后，按照要求的规律摆放，特别注意最后一行。

#### 69.开方取整。

思路：二分查找。

#### 70.n级楼梯，每次可爬1级或2级，返回爬的种数。

思路：递归，f(n) = f(n-1) + f(n-2)。

#### 71.字符串表示路径，返回简化后的路径。

思路：split方法分割字符串为字符串数组，然后再按照逻辑拼接。

#### 72.给定两个字符串，通过插入、移除、替换三种操作，返回从第一个字符串编辑为第二个字符串需要的步数。

思路：二维数组动态规划。word1.charAt(i) == word2.charAt(j)时，dp[i+1][j+1] = dp[i][j]，否则为1 + min{上、左、左上}，分别对应于删除、插入、替换。

#### 73.m * n的二维数组，将存在0的行和列都置为0。

思路：先遍历一遍，记录需要置为0的行和列。

#### 74.在m * n的二维数组中查找某个数，每一行中数字递增，每一行最小数字大于上一行最大数字。

思路：先找在哪一行，再在某一行中二分查找。

#### 75.由0,1,2组成数组，经过一轮遍历进行排序。

思路：zeroPos保存可供交换为0的最前面的位置，该位置之前的都已经置为0保存。
twoPos可供交换为2的最后面的位置，该位置之后的都已经置为2。
依次找0和2，0与zeroPos交换，2与twoPos交换。

#### 76.两个字符串S和T，在S中寻找最短子字符串，使得子字符串包含T中所有出现的字符。

思路：先用数组记录t字符串的特征。两个指针，伸缩尺的思想。
lo,hi分别为字符串低指针，高指针，hi-lo+1为字符串长度，初始时hi和lo都在最左侧。
hi先移动，如果碰到是t中字符，就cnt++。
当cnt与t长度相等，说明所有字符都已经出现，再去改变lo指针位置，缩短长度，直到不满足cnt == t.length()。。

#### 77.给定n和k，返回所有1--n数字中k个数的列表。

思路：backTracking。

#### 78.不包含重复数字的数组，返回所有子集。

思路：backTracking。

#### 79.在二维字符数组中查找给定的单词，返回是否存在。

思路：以每个位置为起始去backTracking。

#### 80.在有序数组中移除重复的数字，每个数最多出现两次，末尾剩余的数字无关紧要。

思路：真实index递增，并用HashMap记录出现的次数。

#### 81.可能有重复数字的有序数组以某位置为轴反转，在其中寻找给定的数字，返回是否找到。

思路：判断转轴位置，以判断左右两侧哪侧递增。二分查找。
特别注意转轴在重复的数字的情况，这时候right或者left（看跟哪个比的）不应该由mid决定。而应该是left++或者right--。

#### 82.从有序链表中移除重复数字，重复数字全部移除。

思路：fakeHead，找到开始重复的节点后一直向后。

#### 83.从有序链表中移除重复数字，只保留一个数字。

思路：删除重复的ListNode，要注意当不重复可以直接curr = curr.next，但是删除重复的节点后，不能直接curr = curr.next。

#### 84.数组表示的柱状图，求最大矩形面积。

思路：从每个位置向两侧扩展，扩展的条件是高度大于等于目前位置高度。

#### 85.由0和1组成的二维数组，返回全部由1组成的最大矩形面积。

思路：遍历每一行，每一行都可以得到height[],left[],right[]三个数组
height[i],在当前行的当前列位置，连续的1的高度
left[i],从当前列往左看，如果出现0，则为0，如果出现1，则为向左扩展的最大值。currLeft为从当前位置看，本行最左边的1的列号。
right[i],从当前列往右看，如果出现0，则为n，如果出现1，则为向右扩展的最小值。currRight为从当前位置看，本行最右侧的i的列号

#### 86.给定一个链表和一个数x，重新排列节点使得比x小的节点为左半部分，大于等于x的节点为右半部分，且左右两部分都保持原数字的相对顺序。

思路：依次处理每个节点，链接到left和right上。

#### 87.给定两个字符串s1和s2，判断s2是否为s1的scramble字符串。scramble的定义是将字符串拆分为二叉树，并交换左右子树。

思路：递归。两个字符串符合scramble的条件是，字符都相同，并且可以在字符的某个位置切割后，左右两侧的字符串分别都符合scramble的条件递归，左对左右对右，左对右右对左两种情况。

#### 88.merge两个有序数组到数组1中，数组1中有足够空间。

思路：从右往左遍历，从大到小赋值。

#### 89.给定n，返回n位格雷码（相邻的只相差一比特位）代表的数组。

思路：反向取出上一轮的，再添加第一位数字。

#### 90.可能包含重复数字的数组，返回所有子集。

思路：backTracking。

#### 91.A--Z分别代表1--26，给定非空数字字符串，返回解码为字母的种数。

思路：s长度为1和2时，应该特殊去考虑。其他情况下，认为s的长度从后往前依次扩展，增加一位。该位置可能的解码种数为i+1,i+2位置之和。

#### 92.给定链表和1<=m<=n<=长度，将m与n之间位置的节点反转。

思路：翻转中间的，保存两侧的。

#### 93.给定数字字符串，返回所有可能的IP地址字符串。

思路：backTracking，注意考虑特殊情况，以0开头的数字，超长的字符串。

#### 94.给定二叉树，返回中序遍历得到的数组。

思路：使用Deque当做Stack使用。每个节点如果存在left子节点，就把父节点放入stack，应该后续还要使用父节点，所以一定是stack的结构。
当从stack中取出一个节点后，把它的值放入list。然后如果其有右子节点，则curr为右子节点。右子节点也符合如果有left，依次放入stack的规律。

#### 95.给定整数n，返回所有不同的二叉搜索树。

思路：有范围地(start,end)建立树。

#### 96.给定整数n，返回所有不同的二叉搜索树的种数。

思路：找规律f(0)=1，f(1)=1，f(2)=2=f(1)*f(0) + f(1)*f(0)，f(3)=5=f(2)*f(0) + f(1)*f(1) + f(0)*f(2)

#### 97.给定三个字符串s1，s2，s3，判断是否s3是s1和s2交织而成。

思路：matrix[i][j]代表了使用s1前i位，和s2前j位，能否组成s3的前i + j位置

#### 98.判断给定的二叉树是否为二叉搜索树。

思路：左右子树都是BST,并且root.val大于左侧最大，小于右侧最小。

#### 99.二叉搜索树中两个节点错误地交换了，恢复为二叉搜索树。

思路：对于BST，inorder traverse会产生从小到大排列的数字。所以需要找到的两个交换的节点就是不符合的位置。

#### 100.判断两棵二叉树是否相同。

思路：递归。

#### 101.判断一棵二叉树是否镜像对称。

思路：把问题转化为两棵树的对称。

#### 102.给定一棵二叉树，返回层级遍历的结果，即List&lt;List&lt;Integer&gt;&gt;。

思路：层级遍历。

#### 103.给定一棵二叉树，返回Z字形层级遍历的结果，即List&lt;List&lt;Integer&gt;&gt;。

思路：每次从右侧开始取prev，然后根据flag决定先取左节点还是右节点。

#### 104.给定一棵二叉树，返回最大深度。

思路：递归，左右两子树最大深度 + 1。

#### 105.给定先序和中序遍历的两个数组，返回二叉树。

思路：转化为有在两个给定数组中起始位置，和树节点数目的递归函数。

#### 106.给定中序和后序遍历的两个数组，返回二叉树。

思路：递归构建左右子树。

#### 107.给定一棵二叉树，返回从叶子节点到根节点反向的层级遍历结果，即List&lt;List&lt;Integer&gt;&gt;。

思路：prev和next两个List&lt;TreeNode&gt;。

#### 108.给定有序数组，返回一棵平衡二叉搜索树。

思路：转化为用数组给定范围内数字构建平衡二叉搜索树的递归问题。

#### 109.给定有序链表，返回一棵平衡二叉搜索树。

思路：递归，通过快慢指针每次找到作为root的点，然后分别建立左右子树。。

#### 110.判断一棵二叉树是否为平衡二叉树。

思路：获得左右子树的深度，考虑平衡二叉树的条件。

#### 111.给定一棵二叉树，返回最小深度。

思路：递归。

#### 112.给定一棵二叉树，判断是否存在从根节点到叶子节点的路径和为给定数字。

思路：递归。

#### 113.给定一棵二叉树，返回所有可能的路径List&lt;List&lt;Integer&gt;&gt;，使得从根节点到叶子节点的路径和为给定数字。

思路：backTracking。

#### 114.给定一棵二叉树，使之变平为一个链表。

思路：递归，先移动左子树，后移动右子树。

#### 115.给定字符串S和T，从S中选取一些字符拼接起来正好与T相等，返回选取的种数。

思路：backTracking方法会超时。
matrix[i][j]表示s的前i位，t的前j位，满足条件的种数，当S增加了一位，增加的一位可以参与匹配，也可以不参与匹配。
参与匹配时(必须s.charAt(i-1) == t.charAt(j-1))种数加matrix[i-1][j-1]，不参与匹配时种数加matrix[i-1][j]。

#### 116.给定一棵完整二叉树，每个节点有三个指针分别是left,right,next，将同一层级中的节点通过next指针相连。

思路：prev和next两个list，层级遍历，每次层级建立next指针。

#### 117.给定一棵二叉树，每个节点有三个指针分别是left,right,next，将同一层级中的节点通过next指针相连。

思路：prev和next两个list，层级遍历，每次层级建立next指针。

#### 118.给定n，按照帕斯卡三角形的规则，返回各层级的数字，即List&lt;List&lt;Integer&gt;&gt;。

思路：根据上一层生成下一层数字。

#### 119.按照帕斯卡三角形的规则，返回索引为n的层级的数组成的列表。

思路：prev,next两个List&lt;Integer>&gt;。

#### 120.给定三角形，即List&lt;List&lt;Integer&gt;&gt;，只能走层级间相邻位置，返回从三角形头部到底部的最小路径和。

思路：从底部向上更新三角形。

#### 121.给定一数组，代表每天的价格，只允许最多进行一次交易，买一次卖一次，返回最大利润。

思路：方法1：计算价格变动，然后计算变动累计，累计负值放弃，正值保留。
方法2：参考session2 q121的解法，所谓的买卖一次的最大利润，就是对于某一天，找到在它之前的最小值，计算差。。

#### 122.给定一数组，代表每天的价格，允许进行任意多次交易，返回最大利润。

思路：比较相邻值，如果正值添加到temp中，表示持续增长，如果负值，累加到sum中。

#### 123.给定一数组，代表每天的价格，只允许最多进行两次交易，返回最大利润。

思路：buy1,buy2,sell1,sell2分别记录第一次买，第二次买，第一次卖，第二次卖时的最大值。

#### 124.给定一棵二叉树，返回最大的从某个节点到另一个节点的路径和。

思路：将问题转化为递归函数maxPathDown，该函数返回以输入节点为父节点的单条路径的最大值（不能左右子树的路径都包括，这样就分叉了），在递归过程中不断比较更新全局的最大值maxValue。

#### 125.判断一个字符串是否回文，忽略大小写和符号。

思路：过滤不符合的，左右两个指针依次比较。

#### 126.给定起始字符串，终止字符串，以及字符串列表，每次只能变化一个字符，且变化的字符在字符串列表中，返回所有可能的最短字符串变化过程列表，即List&lt;List&lt;String&gt;&gt;。

思路：方法1：backTracking时间超限。
方法2：先BFS，用neighbours（HashMap&lt;String,List&lt;String&gt;&gt;）保存每个字符串和变化一个字符后可能达到的字符串列表。
distance（HashMap&lt;String, Integer&gt;）保存每个字符串和从起始字符串变化到当前字符串需要的最小步数。
最后再通过DFS得到所有解。

#### 127.给定起始字符串，终止字符串，以及字符串列表，每次只能变化一个字符，且变化的字符在字符串列表中，返回从起始字符串变化到终止字符串需要的最小步数。

思路：方法1：backTracking时间超限。方法2：用队列去层级遍历，queue中的字符串，循环改变每一个字符，如果在可选字符串列表中就用reached记录曾出现过，每完成一个层级的循环level++。

#### 128.。

思路：。

#### 129.。

思路：。

#### 130.。

思路：。

TODO。。。。。。

# 二、代码

1.[zhhgit github leetcode solution java](https://github.com/zhhgit/leetcode_solution_java)

