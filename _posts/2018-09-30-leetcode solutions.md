---
layout: post
title: "LeetCode思路整理"
description: LeetCode思路整理
modified: 2018-09-30
category: Algorithm
tags: [Algorithm]
---

2016年参加工作以来，为了提高基础能力、保持编码手感，进行了三轮LeetCode Java刷题。

第一遍：2016.12-2017.4，106题，主要是easy和medium的题。第一遍感觉非常吃力，很多题目是看别人的解答去理解，并逐渐熟练语法特性。

第二遍：2017.10.-2018.3，187题，主要是easy和medium的题，少部分hard题目。这一遍头脑里从混乱无章法到逐渐有逻辑有思路。

第三遍：2018.4-2018.9，155题，初始题库前155题的各类型题，大部分easy和medium可以有思路并解答，部分hard题还得看解答。

# 一、题目思路整理

前155题及思路整理如下，三遍刷题代码见github。（近期逐渐整理）

*1.有序数组中找到两个数，和正好为某个值，返回这两个数字的序号。

思路：没有说数组是否有序，所以一定不可能是先sort之后再去找的。那就需要按照原排列顺序，需要记住曾经出现过的数字的位置。HashMap。

2.两个数值从后往前的链表，数值做加法，返回新链表。

思路：用0补齐长度，然后分别计算每一个节点相加的和，注意进位。

3.字符串中最长的不包含重复字符的子字符串，返回该字符串的长度。

思路：碰到曾经出现的字符，就从队列头部开始移除，直至移除相同的字符。

4.两个有序数组，返回所有数字排序后的中位数。

思路：数组长度假设分别为m,n。假设i,j分别为两个数组中的切割点。分别切割为A[0]---A[i-1],A[i]---A[m-1]和B[0]---B[j-1],B[j]---B[n-1];
应该保证j = (m+n+1)/2 - i。此时和为偶数时，两边各一半，为奇数时，左边比右边长1。
目标就是寻找一个合适的i,使得A[i-1] <= B[j],B[j-1] <= A[i]，此时所有两侧正好分成两半，且左侧的都小于右侧的。
特殊情况要考虑，切割点在最左、最右侧时。

5.返回字符串的子字符串中最长的回文字符串。

思路：从字符串的每个位置开始向两侧扩张。两种方式，一种是从同一个位置开始，另一种是从相邻位置开始。

6.原字符转按照蛇形方式重新排序成n行，返回重排后各行拼接而成的字符串。

思路：对字符分组，并找规律，List<List<Character>>。

7.反转整数。

思路：用long类型来转换，考虑溢出的情况。

8.字符串转化为整数。

思路：考虑各种异常情况，开头空白，开头非数字，正负号等。

9.判断一个数字是否为回文数。

思路：回文数都是正整数，long类型先翻转数字顺序，再比较。

10.判断字符串与正则字符串是否匹配。字符.代表任意一位，字符*与前一位组合代表0位或者多位。

思路：二维数组，如果s，p新增的最后一位相等，或者p最后一位为.，则matrix[i + 1][j + 1]与左上角相等。
如果p最后一位为*，如果p中*的前一位与s中当前位相等，或者p中*的前一位为.，则a*或者.*匹配情况有三种：
matrix[i + 1][j + 1]为matrix[i + 1][j]（情况1：对应于一位），
或为matrix[i + 1][j - 1]（情况2：对应于0位）
或为matrix[i][j+1]（情况3：对应于多位）
否则a*匹配0位。

11.一个数组中的数代表容器的侧壁高度，选择两个侧壁，求最大容积。

思路：假设左右两边相比，左侧更小，那么右侧向中心移动时，不管右侧的新值比左侧值更小或者更大，都会使总储水量减小。所以此时不应该把右侧向中心移动，应该移动左侧。

12.正整数转化为罗马字母表示的字符串

思路：对于每一位数字的替换应该抽象为one,half,full。要考虑0--9应该分别怎样替换。

13.罗马字母转换为数字。

思路：先遍历一遍累加，再减去双倍的小数位于大数左侧的情况的和。

14.一组字符串，找到共同的前缀。

思路：依次检查每个位置，所有的字符串是否都是相同的char

15.一个数组，找到其中可重复的三个数字和为0，返回这样的三个数的所有解答，即List<List<Integer>>。

思路：对于每个数字，通过left，right来夹逼remain。特别要注意造成超时的几个点：
(1)选取第一个数字时候，如果有重复要跳过；
(2)在每一轮的left,right夹逼remain时候，如果remain小于0，可以直接跳过；
(3)lists.contains(addList)判断是否重复，会造成超时；
(4)nums[left] + nums[right] == remain找到后，先left++,right--，然后要跳过重复；
(5)不等于remain时候，单边的left++或者right--也可以跳过重复（不跳过不会超时）；

16.一个数组，找到其中可重复的三个数字和，与target值最接近，返回最接近的三个数的和。

思路：与15题类似，通过left，right来夹逼remain。

17.电话上2-9的数字分别代表几个字符，给出一个数字字符串，求所有可能对应的字符串。

思路：(1)backTracking，更优。(2)处理每一位时，将list中已经存在的String全部取出处理一遍。

18.一个数组，找到其中可重复的四个数字和为target，返回这样的四个数的所有解答，即List<List<Integer>>。

思路：与15题类似，双层循环，然后最后两个数left，right左右夹逼。

19.一个链表，移除从末尾数第n个节点。

思路：快慢指针，特别要注意移除的是head的情况。

20.判断字符串是否为合法闭合的括号对。

思路：Deque<Character>当做栈使用，注意要保证stack中有元素，否则stack.peek()为null，null再与'(','[','{'在用==比较时，会抛异常。

21.merge两个有序链表。

思路：递归，每次处理一个ListNode。

22.返回所有由n对括号组成的合法闭合的括号对字符串。

思路：递归，左括号个数要比右括号个数多。

23.k个有序链表，merge成一个。

思路：递归，每次处理一个ListNode。

24.链表中的节点每两个一组交换位置。

思路：每两个作为一组，完成位置交换之后递归。

25.链表中的节点每k个一组逆序。

思路：只考虑反转k个节点，后面的递归。

TODO。。。。。。

# 二、代码

1.[zhhgit github leetcode solution java](https://github.com/zhhgit/leetcode_solution_java)

