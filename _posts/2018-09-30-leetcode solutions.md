---
layout: post
title: "LeetCode思路整理"
description: LeetCode思路整理
modified: 2018-09-30
category: Algorithm
tags: [Algorithm]
---

2016年参加工作以来，为了提高基础能力、保持编码手感，进行了三轮LeetCode Java刷题。

第一遍：2016.12-2017.4，106题，主要是easy和medium的题。第一遍感觉非常吃力，很多题目是看别人的解答去理解，并逐渐熟练语法特性。

第二遍：2017.10.-2018.3，187题，主要是easy和medium的题，少部分hard题目。这一遍头脑里从混乱无章法到逐渐有逻辑有思路。

第三遍：2018.4-2018.9，155题，初始题库前155题的各类型题，大部分easy和medium可以有思路并解答，部分hard题还得看解答。

# 一、题目思路整理

前155题及思路整理如下，三遍刷题代码见github。（近期逐渐整理）

#### 1.有序数组中找到两个数，和正好为某个值，返回这两个数字的序号。

思路：没有说数组是否有序，所以一定不可能是先sort之后再去找的。那就需要按照原排列顺序，需要记住曾经出现过的数字的位置。HashMap。

#### 2.两个数值从后往前的链表，数值做加法，返回新链表。

思路：用0补齐长度，然后分别计算每一个节点相加的和，注意进位。

#### 3.字符串中最长的不包含重复字符的子字符串，返回该字符串的长度。

思路：碰到曾经出现的字符，就从队列头部开始移除，直至移除相同的字符。

#### 4.两个有序数组，返回所有数字排序后的中位数。

思路：数组长度假设分别为m,n。假设i,j分别为两个数组中的切割点。分别切割为A[0]---A[i-1],A[i]---A[m-1]和B[0]---B[j-1],B[j]---B[n-1];
应该保证j = (m+n+1)/2 - i。此时和为偶数时，两边各一半，为奇数时，左边比右边长1。
目标就是寻找一个合适的i,使得A[i-1] <= B[j],B[j-1] <= A[i]，此时所有两侧正好分成两半，且左侧的都小于右侧的。
特殊情况要考虑，切割点在最左、最右侧时。

#### 5.返回字符串的子字符串中最长的回文字符串。

思路：从字符串的每个位置开始向两侧扩张。两种方式，一种是从同一个位置开始，另一种是从相邻位置开始。

#### 6.原字符转按照蛇形方式重新排序成n行，返回重排后各行拼接而成的字符串。

思路：对字符分组，并找规律，List<List<Character>>。

#### 7.反转整数。

思路：用long类型来转换，考虑溢出的情况。

#### 8.字符串转化为整数。

思路：考虑各种异常情况，开头空白，开头非数字，正负号等。

#### 9.判断一个数字是否为回文数。

思路：回文数都是正整数，long类型先翻转数字顺序，再比较。

#### 10.判断字符串与正则字符串是否匹配。字符.代表任意一位，字符*与前一位组合代表0位或者多位。

思路：二维数组，如果s，p新增的最后一位相等，或者p最后一位为.，则matrix[i + 1][j + 1]与左上角相等。
如果p最后一位为*，如果p中*的前一位与s中当前位相等，或者p中*的前一位为.，则a*或者.*匹配情况有三种：
matrix[i + 1][j + 1]为matrix[i + 1][j]（情况1：对应于一位），
或为matrix[i + 1][j - 1]（情况2：对应于0位）
或为matrix[i][j+1]（情况3：对应于多位）
否则a*匹配0位。

#### 11.一个数组中的数代表容器的侧壁高度，选择两个侧壁，求最大容积。

思路：假设左右两边相比，左侧更小，那么右侧向中心移动时，不管右侧的新值比左侧值更小或者更大，都会使总储水量减小。所以此时不应该把右侧向中心移动，应该移动左侧。

#### 12.正整数转化为罗马字母表示的字符串

思路：对于每一位数字的替换应该抽象为one,half,full。要考虑0--9应该分别怎样替换。

#### 13.罗马字母转换为数字。

思路：先遍历一遍累加，再减去双倍的小数位于大数左侧的情况的和。

#### 14.一组字符串，找到共同的前缀。

思路：依次检查每个位置，所有的字符串是否都是相同的char

#### 15.一个数组，找到其中可重复的三个数字和为0，返回这样的三个数的所有解答，即List<List<Integer>>。

思路：对于每个数字，通过left，right来夹逼remain。特别要注意造成超时的几个点：
(1)选取第一个数字时候，如果有重复要跳过；
(2)在每一轮的left,right夹逼remain时候，如果remain小于0，可以直接跳过；
(3)lists.contains(addList)判断是否重复，会造成超时；
(4)nums[left] + nums[right] == remain找到后，先left++,right--，然后要跳过重复；
(5)不等于remain时候，单边的left++或者right--也可以跳过重复（不跳过不会超时）；

#### 16.一个数组，找到其中可重复的三个数字和，与target值最接近，返回最接近的三个数的和。

思路：与15题类似，通过left，right来夹逼remain。

#### 17.电话上2-9的数字分别代表几个字符，给出一个数字字符串，求所有可能对应的字符串。

思路：(1)backTracking，更优。(2)处理每一位时，将list中已经存在的String全部取出处理一遍。

#### 18.一个数组，找到其中可重复的四个数字和为target，返回这样的四个数的所有解答，即List<List<Integer>>。

思路：与15题类似，双层循环，然后最后两个数left，right左右夹逼。

#### 19.一个链表，移除从末尾数第n个节点。

思路：快慢指针，特别要注意移除的是head的情况。

#### 20.判断字符串是否为合法闭合的括号对。

思路：Deque<Character>当做栈使用，注意要保证stack中有元素，否则stack.peek()为null，null再与'(','[','{'在用==比较时，会抛异常。

#### 21.merge两个有序链表。

思路：递归，每次处理一个ListNode。

#### 22.返回所有由n对括号组成的合法闭合的括号对字符串。

思路：递归，左括号个数要比右括号个数多。

#### 23.k个有序链表，merge成一个。

思路：递归，每次处理一个ListNode。

#### 24.链表中的节点每两个一组交换位置。

思路：每两个作为一组，完成位置交换之后递归。

#### 25.链表中的节点每k个一组逆序。

思路：只考虑反转k个节点，后面的递归。

#### 26.有序数组中只留下不重复的数字，且都移动到数组的最前面。

思路：从前往后遍历，符合条件的依次填入相应的位置。

#### 27.有序数组中移除与指定数字相等的值，留下的都移动到数组的最前面。

思路：从前往后遍历，符合条件的依次填入相应的位置。

#### 28.返回子字符串第一次出现的起始位置。

思路：依次比较。

#### 29.不使用乘除法，实现两个整数相除。

思路：多次的位运算左移，要考虑边际的特殊情况。

#### 30.一个字符串和一个字符串数组（数组中所有字符串等长），返回字符串数组中全部字符串拼接得到的字符串，在第一个字符串中的起始位置。

思路：先建立一个HashMap记录words中词应该出现的次数，再遍历字符串，每次截取等长的，如果出现不应该出现的，或者出现的次数超过应该出现的次数，就break，否则验证到最后了就是符合的。

#### 31.求比数组中数字代表的值大的下一个数组排列，对原数组操作。

思路：从末尾开始找到非递增的位置，然后从其后面找到一个比它稍大的数字的位置，并交换。最后重排非递增位置的后续其他位置的数。

#### 32.由小括号组成的字符串，求最长的正确闭合的子字符串的长度。

思路：依次以每个位置为起始，符合闭合的条件是left == right,可以继续循环的条件是left >= right。

#### 33.无重复数字的有序数组以某位置为轴反转，在其中寻找给定的数字，找到返回位置，没找到返回-1。

思路：判断转轴位置，以判断左右两侧哪侧递增。二分查找。

#### 34.有序数组中查找指定数字，返回指定数字的最左、最右位置，没有就返回[-1,-1]。

思路：二分查找，找到后向两边扩展。

#### 35.有序数组中查找指定数字，找到就返回其位置，没找到就返回其应该插入的位置。

思路：按顺序找到与target相等或者大于它的位置。

TODO。。。。。。

# 二、代码

1.[zhhgit github leetcode solution java](https://github.com/zhhgit/leetcode_solution_java)

